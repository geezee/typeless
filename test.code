id = lambda t t;
true = lambda t (lambda f t);
false = lambda t (lambda f f);
not = lambda b ((b false) true);
if = lambda b (lambda t (lambda f ((b t) f)));
and = lambda a (lambda b ((a b) false));
or = lambda a (lambda b ((a true) b));
eq-b? = and;

pair = lambda a (lambda b (lambda c (((if c) a) b)));
left = lambda p (p true);
right = lambda p (p false);
apply-if-true = lambda f (lambda p (((if (left p)) ((pair (left p)) (f (right p)))) p));
apply-first = lambda f (lambda p ((pair (f (left p))) (right p)));
apply-second = lambda f (lambda p ((pair (left p)) (f (right p))));
apply-if-else = lambda f (lambda g (lambda p (((if (left p)) (f p)) (g p))));

zero = lambda S (lambda z z);
succ = lambda n (lambda S (lambda z ((n S) (S z))));
zero? = lambda b ((b (lambda _ false)) true);
add = lambda n (lambda m (lambda S (lambda z ((n S) ((m S) z)))));
mult = lambda n (lambda m (lambda S (lambda z ((m (n S)) z))));
odd? = lambda b ((b not) false);
even? = lambda b ((b not) true);

pred_h = lambda n ((n (lambda p (((apply-if-else (apply-first not))
                                                 (apply-second succ))
                                  p)))
                      ((pair true) zero));
pred = lambda n (right (pred_h n));
minus = lambda n (lambda m ((m pred) n));
eq-n? = lambda n (lambda m ((and (zero? ((minus n) m)))
                                 (zero? ((minus m) n))));

0 = zero;
1 = (succ 0);
2 = (succ 1);
3 = ((mult (succ 2)) 1);
4 = ((add 3) 1);
5 = (pred ((add 2) 4));
8 = ((add 4) ((mult 2) 2));
10 = ((mult 5) 2);

print-num = lambda n ((n (lambda _ (print 1))) 0);

fact = lambda n ((((if (zero? n)) (lambda _ 1)) (lambda _ ((mult n) (fact (pred n))))) id);

main = (print-num (fact 8))
